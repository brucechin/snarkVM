// Copyright (C) 2019-2021 Aleo Systems Inc.
// This file is part of the snarkVM library.

// The snarkVM library is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// The snarkVM library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with the snarkVM library. If not, see <https://www.gnu.org/licenses/>.

use crate::{Network, errors::TransactionError, testnet1::{AleoAmount, BaseDPCComponents, record::encrypted_record::*}};
use snarkvm_algorithms::{
    merkle_tree::MerkleTreeDigest,
    traits::{CommitmentScheme, SignatureScheme, CRH, SNARK},
};
use snarkvm_utilities::{
    bytes::{FromBytes, ToBytes},
    serialize::{CanonicalDeserialize, CanonicalSerialize},
};

use blake2::{digest::Digest, Blake2s as b2s};
use std::{
    fmt,
    io::{Read, Result as IoResult, Write},
};

pub type TransactionHash = [u8; 32];

#[derive(Clone, PartialEq, Eq)]
// TODO (howardwu): Remove the public visibility here
pub struct Transaction {
    /// The network this transaction is included in
    pub network: Network,

    /// The root of the ledger commitment Merkle tree
    pub ledger_digest: TransactionHash,

    /// The serial numbers of the records being spend
    pub old_serial_numbers: Vec<TransactionHash>,

    /// The commitment of the new records
    pub new_commitments: Vec<TransactionHash>,

    /// The commitment to the old record death and new record birth programs
    pub program_commitment: TransactionHash,

    /// The root of the local data merkle tree
    pub local_data_root: TransactionHash,

    /// A transaction value balance is the difference between input and output record balances.
    /// This value effectively becomes the transaction fee for the miner. Only coinbase transactions
    /// can have a negative value balance representing tokens being minted.
    pub value_balance: AleoAmount,

    /// Randomized signatures that allow for authorized delegation of transaction generation
    pub signatures: Vec<TransactionHash>,

    /// Encrypted record and selector bits of the new records generated by the transaction
    pub encrypted_records: Vec<EncryptedRecord>,

    /// Zero-knowledge proof attesting to the valididty of the transaction
    pub transaction_proof: Vec<u8>,

    /// Public data associated with the transaction that must be unique among all transactions
    pub memorandum: [u8; 32],

    /// The ID of the inner SNARK being used
    pub inner_circuit_id: TransactionHash,
}

impl Transaction {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        old_serial_numbers: Vec<TransactionHash>,
        new_commitments: Vec<TransactionHash>,
        memorandum: TransactionHash,
        ledger_digest: TransactionHash,
        inner_circuit_id: TransactionHash,
        transaction_proof: Vec<u8>,
        program_commitment: TransactionHash,
        local_data_root: TransactionHash,
        value_balance: AleoAmount,
        network: Network,
        signatures: Vec<TransactionHash>,
        encrypted_records: Vec<EncryptedRecord>,
    ) -> Self {
        Self {
            old_serial_numbers,
            new_commitments,
            memorandum,
            ledger_digest,
            inner_circuit_id,
            transaction_proof,
            program_commitment,
            local_data_root,
            value_balance,
            network,
            signatures,
            encrypted_records,
        }
    }
}

impl Transaction {
    /// Transaction id = Hash of (serial numbers || commitments || memo)
    pub fn transaction_id(&self) -> Result<[u8; 32], TransactionError> {
        let mut pre_image_bytes: Vec<u8> = vec![];

        for sn in &self.old_serial_numbers {
            pre_image_bytes.extend(sn);
        }

        for cm in &self.new_commitments {
            pre_image_bytes.extend(cm);
        }

        pre_image_bytes.extend(&self.memorandum);

        let mut h = b2s::new();
        h.update(&pre_image_bytes);

        let mut result = [0u8; 32];
        result.copy_from_slice(&h.finalize());
        Ok(result)
    }
}

impl Transaction {
    pub fn write<C: BaseDPCComponents, W: Write>(&self, mut writer: W) -> IoResult<()> {
        for old_serial_number in &self.old_serial_numbers {
            CanonicalSerialize::serialize(&old_serial_number[..], &mut writer).unwrap();
        }

        for new_commitment in &self.new_commitments {
            new_commitment.write(&mut writer)?;
        }

        self.memorandum.write(&mut writer)?;

        self.ledger_digest.write(&mut writer)?;
        self.inner_circuit_id.write(&mut writer)?;
        self.transaction_proof.write(&mut writer)?;
        self.program_commitment.write(&mut writer)?;
        self.local_data_root.write(&mut writer)?;

        self.value_balance.write(&mut writer)?;
        self.network.write(&mut writer)?;

        for signature in &self.signatures {
            signature.write(&mut writer)?;
        }

        for encrypted_record in &self.encrypted_records {
            encrypted_record.write::<C, _>(&mut writer)?;
        }

        Ok(())
    }

    pub fn read<C: BaseDPCComponents, R: Read>(mut reader: R) -> IoResult<Self> {
        // Read the old serial numbers
        let num_old_serial_numbers = C::NUM_INPUT_RECORDS;
        let mut old_serial_numbers = Vec::with_capacity(num_old_serial_numbers);
        for _ in 0..num_old_serial_numbers {
            let old_serial_number: <C::AccountSignature as SignatureScheme>::PublicKey =
                CanonicalDeserialize::deserialize(&mut reader).unwrap();

            old_serial_numbers.push(old_serial_number.to_array::<32>()?);
        }

        // Read the new commitments
        let num_new_commitments = C::NUM_OUTPUT_RECORDS;
        let mut new_commitments = Vec::with_capacity(num_new_commitments);
        for _ in 0..num_new_commitments {
            let new_commitment: <C::RecordCommitment as CommitmentScheme>::Output = FromBytes::read(&mut reader)?;
            new_commitments.push(new_commitment.to_array::<32>()?);
        }

        let memorandum: [u8; 32] = FromBytes::read(&mut reader)?;

        let ledger_digest: MerkleTreeDigest<C::MerkleParameters> = FromBytes::read(&mut reader)?;
        let inner_circuit_id: <C::InnerCircuitIDCRH as CRH>::Output = FromBytes::read(&mut reader)?;
        let transaction_proof: <C::OuterSNARK as SNARK>::Proof = FromBytes::read(&mut reader)?;
        let program_commitment: <C::ProgramVerificationKeyCommitment as CommitmentScheme>::Output =
            FromBytes::read(&mut reader)?;
        let local_data_root: <C::LocalDataCRH as CRH>::Output = FromBytes::read(&mut reader)?;

        let value_balance: AleoAmount = FromBytes::read(&mut reader)?;
        let network: Network = FromBytes::read(&mut reader)?;

        // Read the signatures
        let num_signatures = C::NUM_INPUT_RECORDS;
        let mut signatures = Vec::with_capacity(num_signatures);
        for _ in 0..num_signatures {
            let signature: <C::AccountSignature as SignatureScheme>::Output = FromBytes::read(&mut reader)?;
            signatures.push(signature.to_array::<32>()?);
        }

        // Read the encrypted records
        let num_encrypted_records = C::NUM_OUTPUT_RECORDS;
        let mut encrypted_records = Vec::with_capacity(num_encrypted_records);
        for _ in 0..num_encrypted_records {
            let encrypted_record = EncryptedRecord::read::<C, _>(&mut reader)?;

            encrypted_records.push(encrypted_record);
        }

        Ok(Self {
            network,
            ledger_digest: ledger_digest.to_array()?,
            old_serial_numbers,
            new_commitments,
            program_commitment: program_commitment.to_array()?,
            local_data_root: local_data_root.to_array()?,
            value_balance,
            signatures,
            encrypted_records,
            inner_circuit_id: inner_circuit_id.to_array()?,
            transaction_proof: transaction_proof.to_bytes()?,
            memorandum,
        })
    }
}

// TODO add debug support for record ciphertexts
impl fmt::Debug for Transaction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Transaction {{ network_id: {:?}, digest: {:?}, inner_circuit_id: {:?}, old_serial_numbers: {:?}, new_commitments: {:?}, program_commitment: {:?}, local_data_root: {:?}, value_balance: {:?}, signatures: {:?}, transaction_proof: {:?}, memorandum: {:?} }}",
            self.network,
            self.ledger_digest,
            self.inner_circuit_id,
            self.old_serial_numbers,
            self.new_commitments,
            self.program_commitment,
            self.local_data_root,
            self.value_balance,
            self.signatures,
            self.transaction_proof,
            self.memorandum,
        )
    }
}
